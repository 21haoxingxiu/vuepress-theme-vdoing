(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{483:function(t,a,e){"use strict";e.r(a);var s=e(15),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"javascript-是单线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-是单线程"}},[t._v("#")]),t._v(" JavaScript 是单线程")]),t._v(" "),e("p",[t._v("本文来源："),e("a",{attrs:{href:"https://juejin.im/post/5bc2a2d9f265da0ab915edd8",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.im/post/5bc2a2d9f265da0ab915edd8"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("首先我们了解一下进程和线程的概念和关系：")]),t._v(" "),e("ul",[e("li",[t._v("进程：运行的程序就是一个进程，比如你正在运行的浏览器，它会有一个进程；")]),t._v(" "),e("li",[t._v("线程：程序中独立运行的代码段。一个进程 由单个或多个 线程 组成，线程是负责执行代码的。")]),t._v(" "),e("li")]),t._v(" "),e("h3",{attrs:{id:"单线程与多线程的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单线程与多线程的区别"}},[t._v("#")]),t._v(" 单线程与多线程的区别：")]),t._v(" "),e("p",[e("strong",[t._v("单线程")]),t._v("：从头执行到尾，一行行执行，如果其中一行代码报错，那么剩下的代码将不再执行。同时容易代码阻塞。")]),t._v(" "),e("p",[e("strong",[t._v("多线程")]),t._v("：代码运行的环境不同，各线程独立，互不影响，避免阻塞。")]),t._v(" "),e("p",[t._v("为了保证 JavaScript 的主要运行环境（浏览器），JavaScript 被设计成了单线程语言。")]),t._v(" "),e("p",[t._v("为了充分利用多核处理器的计算能力，HTML5 提出了 Web Worker 标准，允许 JavaScript 脚本创建多个子线程，但是子线程完全受控于主线程，且不得操作 DOM。因此，新标准并没有改变 JavaScript 单线程的本质。")]),t._v(" "),e("h2",{attrs:{id:"执行栈、任务队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行栈、任务队列"}},[t._v("#")]),t._v(" 执行栈、任务队列")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/21haoxingxiu/picture/master/blog/20210305104218.png",alt:""}})]),t._v(" "),e("p",[t._v("在上图中，主线程运行的时候，产生 堆（heap） 和 栈（stack），栈中的代码调用各种 API，他们在 任务队列 中加入各种事件（DOM Event，ajax，setTimeout...），只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些时间对应的回调函数。")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("堆（heap）")]),t._v("：对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("执行栈（stack）")]),t._v("：运行同步代码。执行栈中的代码（同步任务），总是在读取 任务队列（异步任务）之前执行。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("任务队列（callback queue）")]),t._v("：")])])]),t._v(" "),e("p",[t._v("任务队列 是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在 任务队列 中添加一个事件，表示相关的异步任务可以进入 执行栈 了。主线程读取 任务队列，就是读取里面有哪些事件。")]),t._v(" "),e("p",[t._v("任务队列 中的事件，除了 IO 设备的事件外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等）。只要指定过回调函数，这些事件发生时就会进入 任务队列，等待主线程读取。")]),t._v(" "),e("p",[t._v("所谓 回调函数（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。")]),t._v(" "),e("p",[t._v("任务队列 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本是自动的，只要执行栈一清空。任务队列 上第一位的事件就自动进入主线程。但是由于存在后文提到的 定时器 功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间才能返回主线程。")]),t._v(" "),e("h2",{attrs:{id:"同步任务、异步任务、宏任务、微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步任务、异步任务、宏任务、微任务"}},[t._v("#")]),t._v(" 同步任务、异步任务、宏任务、微任务")]),t._v(" "),e("p",[t._v("单线程即意味着所有人物都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就必须一直等着。")]),t._v(" "),e("h3",{attrs:{id:"同步任务、异步任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步任务、异步任务"}},[t._v("#")]),t._v(" 同步任务、异步任务")]),t._v(" "),e("p",[t._v("为此，JavaScript 设计者在广义上将所有任务分成两种：同步任务（synchronous）、异步任务（asynchronous），运行机制如下：")]),t._v(" "),e("ol",[e("li",[t._v("所有同步任务都在主线程上执行，形成一个 执行栈；")]),t._v(" "),e("li",[t._v("主线程外，还存在一个 任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件；")]),t._v(" "),e("li",[t._v("一旦执行栈中所有同步任务执行完毕，系统就会取出任务队列中事件对应的回调函数进入执行栈，开始执行；")]),t._v(" "),e("li",[t._v("主线程不断重复上面的第三部。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/21haoxingxiu/picture/master/blog/20210305105934.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"宏任务、微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宏任务、微任务"}},[t._v("#")]),t._v(" 宏任务、微任务")]),t._v(" "),e("p",[t._v("除了广义上的定义，我们将任务进行更精细的定义，分为：")]),t._v(" "),e("ul",[e("li",[e("h3",{attrs:{id:"宏任务-macro-task"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宏任务-macro-task"}},[t._v("#")]),t._v(" 宏任务（macro-task）")])])]),t._v(" "),e("p",[t._v("包括整体代码 script，setTimeout，setInterval，ajax，dom操作")]),t._v(" "),e("ul",[e("li",[e("h3",{attrs:{id:"微任务-micro-task"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微任务-micro-task"}},[t._v("#")]),t._v(" 微任务（micro-task）")])])]),t._v(" "),e("p",[t._v("Promise")]),t._v(" "),e("p",[t._v("运行机制如下：")]),t._v(" "),e("ol",[e("li",[t._v("首先将执行栈最开始的所有同步代码（宏任务）执行完成；")]),t._v(" "),e("li",[t._v("检查是否有微任务，如有则执行所有微任务；")]),t._v(" "),e("li",[t._v("取出任务队列中事件对应的回调函数（宏任务）进入执行栈并执行完成；")]),t._v(" "),e("li",[t._v("再检查是否有微任务，如有则执行所有的微任务；")]),t._v(" "),e("li",[t._v("主线程不断重复上面的 3、4 步。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/21haoxingxiu/picture/master/blog/20210305110050.png",alt:""}})]),t._v(" "),e("p",[t._v("以上两种运行机制，主线程都从任务队列中读取事件，这个过程是循环不断的，所以整个这种运行机制又称为 Event Loop（事件循环）")]),t._v(" "),e("h3",{attrs:{id:"settimeout、setinterval"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#settimeout、setinterval"}},[t._v("#")]),t._v(" setTimeout、setInterval")]),t._v(" "),e("p",[t._v("这两个函数内部运行机制完全一致，区别在于前者一次性执行，后者反复执行。")]),t._v(" "),e("p",[t._v("两者产生的任务都是 "),e("strong",[t._v("异步任务")]),t._v("，也属于 "),e("strong",[t._v("宏任务")]),t._v("。")]),t._v(" "),e("p",[t._v("setTimeout 接收两个参数，第一个是回调函数，第二个是延迟执行的毫秒数。")]),t._v(" "),e("p",[t._v("如果第二个参数设置为0或者不设置，意思 "),e("strong",[t._v("并不是立即执行，而是指定某个任务在主线程最早可得到的空闲时间执行，也就是说，尽可能早得执行。他在 任务队列 的尾部添加一个事件，因此要等到同步任务和 任务队列 现有的事件都处理完，才会得到执行")]),t._v("。")]),t._v(" "),e("p",[t._v("所以说，setTimeout 和 setInterval 第二个参数设置的时间并不是绝对的，它需要根据当前代码最终执行的时间来确定的，简单来说，如果当前代码执行的时间超出了推迟执行的时间，那么 setTimeout(fn, 100) 就和 setTimeout(fn, 0) 没有区别了。")]),t._v(" "),e("h3",{attrs:{id:"promise"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),e("p",[t._v("Promise 相对来说比较特殊，在 new Promise() 中传入的回调函数是会 立即执行 的，但是它的 then() 方法是在 执行栈之后，任务队列之前 执行的，它属于 微任务。")]),t._v(" "),e("h3",{attrs:{id:"process-nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick"}},[t._v("#")]),t._v(" process.nextTick")]),t._v(" "),e("p",[t._v("process.nextTick 是 Node.JS 提供的一个与 任务队列 有关的方法，它产生的任务是放在 执行栈的尾部，并不属于 宏任务 和 微任务，因此它的任务 总是发生在所有异步任务之前。")]),t._v(" "),e("h3",{attrs:{id:"setimmediate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setimmediate"}},[t._v("#")]),t._v(" setImmediate")]),t._v(" "),e("p",[t._v("setImmediate 是 Node.js 提供的与 任务队列 有关的方法，它产生的任务追加到 任务队列 的尾部，它和 setTimeout(fn, 0) 很像，但是优先级低于 setTimeout。")]),t._v(" "),e("p",[t._v("有时候，setTimeout 会在 setImmediate 之前执行，有时会在之后执行，这是因为虽然 setTimeout 第二个参数设置为 0 或者不设置，但是 setTimeout 源码中，会指定一个具体的毫秒数（nodejs 为 1ms，浏览器为 4ms），而由于当前代码执行时间收到执行环境的影响，执行时间有所起伏。")]),t._v(" "),e("h2",{attrs:{id:"优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[t._v("#")]),t._v(" 优先级")]),t._v(" "),e("ol",[e("li",[t._v("同步任务（宏任务）")]),t._v(" "),e("li",[t._v("process.nextTick")]),t._v(" "),e("li",[t._v("Promise（微任务）")]),t._v(" "),e("li",[t._v("setTimeout(fn)、setInterval(fn) （宏任务）")]),t._v(" "),e("li",[t._v("setimmediate（宏任务）")]),t._v(" "),e("li",[t._v("setTimeout(fn, time)、setInterval(fn, time) time >0")])])])}),[],!1,null,null,null);a.default=v.exports}}]);