### 混合APP首屏渲染白屏问题

- 针对 WebView 初始化（预渲染）：该过程大致需耗费 70~700ms。当客户端刚启动时，可以先提前初始化一个全局的 WebView 待用并隐藏。当用户访问了 WebView 时，直接使用这个 WebView 加载对应网页并展示。


- 针对向后端发送接口请求：在客户端初始化 WebView 的同时，直接由 Native 开始网络请求数据，当页面初始化完成后，向 Native 获取其代理请求的数据。


- 针对加载的 js 动态拼接 html（单页面应用）：可采用多页面打包， 服务端渲染，以及构建时预渲染等方式。


- 针对加载页面资源的大小：可采用懒加载等方式，将需要较大资源的部分分离出来，等整体页面渲染完成后再异步请求分离出来的资源，以提升整体页面加载速度。

- 离线包（app启动时自动下载）

### 离线包

> 1.离线包的组成

>离线包由h5提供，包里面的结构基本和线上一致，本身我们的h5网页就是放在cdn上，这次只不过是拿出来，打成压缩包，放在Android的apk包里

>2.Android对离线包的解析

>首先，离线包的zip包是放在assets文件夹下，在app启动时，解压zip包到相应的文件夹目录下，拿到这个本地路径

>3.对线上地址的替换

>webview在加载的时候，会调用loadurl方法，此时传进去的url还是线上的url，Android要做的最重要的一步就是重写webviewClient的shouldInterceptRequest方法，在里面拿到要加载的url，并且进行替换，替换成本地url。同样的道理，凡事线上资源都可以进行替换，如css、js、图片资源，还可以通过glide对图片资源进行缓存。


### 混合APP有哪些优化的点

- 跨域问题处理
>由于我们把主页面是打到 APK 中的，请求的时候也是通过 file 协议请求的，而其内部的 Ajax 请求是要请求服务端接口的，这就造成了跨域请求失败问题。

> 客户端 WebView 设置以下属性，以允许 file 协议的页面内部可以向其他源发起 http/https 请求。

```js
setAllowUniversalAccessFromFileURLs(true);
```

- WebView 预加载
- 直出+离线包缓存(webso 和 Alloykit 的离线包方案)
- 服务器进行渲染

### 混合APP遇到哪些兼容性问题

- #### click 点击事件延时与穿透
> 解决方案一：使用 touchstart 替换 click
> 解决方案二：使用 fastclick 库

- #### 现象：IOS使用 new Date('2019-08-20').getMonth() + 1; 获取月份报错 NAN
  
> 使用正则将 '-' 替换为 '/'

- #### 软键盘将页面顶起来、收起未回落问题
> 软键盘将页面顶起来的解决方案，主要是通过监听页面高度变化，强制恢复成弹出前的高度。  

```js
// 记录原有的视口高度
const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;

window.onresize = function(){
  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
  if(resizeHeight < originalHeight ){
    // 恢复内容区域高度
    // const container = document.getElementById("container")
    // 例如 container.style.height = originalHeight;
  }
}
```

- #### IOS中input键盘事件keyup、keydown、keypress支持不是很好

方法：可以用html5的oninput事件去代替keyup

- #### ios 设置input 按钮样式会被默认样式覆盖

```css
input,textarea {
  border: 0;
  -webkit-appearance: none;
}
```

- #### 移动端点透问题

> touchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。

1. 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。
2. 用fastclick
3. 用preventDefault阻止a标签的click

- #### 生成图片

主要是使用 htmlToCanvas 生成 canvas 画布


### 跨域有哪些方法 他们有什么区别
1. CORS （Access-Control-Allow-Origin： *）
2. Nginx 正向代理(服务器端：利用服务端请求不会跨域的特性，让接口和当前站点同域)
3. Nginx 反向代理（客户端）
   ```js
   server {
        listen 80;
        server_name local.test;
        location /api {
            proxy_pass http://localhost:8080;
        }
        location / {
            proxy_pass http://localhost:8000;
        }
      }
   ```
4. charles
5. JSONP(仅支持Get)
6. Websocket(本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制)

### websocket了解吗 把你知道的说下

- 这个 WebSocket 是一种全新的协议。它将 TCP 的 Socket（套接字）应用在了web page上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工（双方同时进行双向通信）。

- 其实是这样的，WebSocket 协议是借用 HTTP协议 的 101 switch protocol 来达到协议转换的，从HTTP协议切换成WebSocket通信协议。

- 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。其他特点包括：


### websocket特点

- 建立在 TCP 协议之上，服务器端的实现比较容易。
- 与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
- 数据格式比较轻量，性能开销小，通信高效。
- 可以发送文本，也可以发送二进制数据。
- 没有同源限制，客户端可以与任意服务器通信。
- 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。


```js
ws.addEventListener("message/open/close", function(event) {
  var data = event.data;
  // 处理数据
});
```


### webpack用过哪些插件
 1. HTML文件生成插件：html-webpack-plugin
 2. 图片压缩插件：imagemin-webpack-plugin
 3. 公共代码抽取插件  optimization.splitChunks
 4. css提取插件：mini-css-extract-plugin （生产模式）
 5. 定义环境变量 definePlugin

### webpack优化 ：

1. 按需加载 babel-plugin-import

2. 写代码时使用import引入而不是require

3. 异步加载资源 const Foo = () => import('./Foo.vue')；

4. 抽离公共模块 optimization splitchunks

### vue组件之间的传值有哪些

> props emit vuex event bus

### vue和react的区别有哪些
   1. 监听数据变化的实现原理不同
   2. 数据流的不同
   3. 组件通信的区别 （vue事件，react回调函数）
   4. 模板渲染方式的不同（template, jsx) 
   5. 渲染过程不同
   6. 理念不同（react 数据不可变）

### vue生命周期
### 浏览器渲染机制
CSS DOM 
HTMl  Dom
Render DOM
JS
paint

### 用户发起请求经历了哪些过程？其中有一个过程是域名解析，域名解析是在哪里实现的（浏览器还是服务器）

在解析过程中，按照浏览器缓存、
系统缓存、路由器缓存、
ISP(运营商)DNS缓存、
根域名服务器、顶级域名服务器、
主域名服务器的顺序，
逐步读取缓存，直到拿到IP地址。

### DNS预解析

预解析： html 源码下载完成后，会解析页面的包含链接的标签，提前查询对应的域名
HTTPS页面中不会自动解析

```html
<link rel="dns-prefetch" href="//g.alicdn.com" />
https: 
<meta http-equiv="x-dns-prefetch-control" content="on">
```


### vue未声明变量实现响应式

1. Vue.$set
2. 对象： Object.assign({}, this.someObject, { a: 1, b: 2 })
3. 数组： [...arr]


### vue编译更新的全过程

### 基本的SEO
- 语义化的HTML代码，符合W3C规范
- 非装饰性图片必须加alt
- 友情链接
- 重要的内容放在前面
- 向各大搜索引擎提交收录自己的站点

### vue的SEO
- 预渲染prerender-spa-plugin（在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件）
>但是现在你看到的会比之前多几个文件夹，多的文件夹正是你配置的那几个路由，每个文件夹中都是一个index.html文件。原本只有一个index.html的单页应用现在变成了多页应用，这也就提升了你的网页被抓取的概率。

![](https://raw.githubusercontent.com/21haoxingxiu/picture/master/blog/20210325133744.png)


- SSR服务器渲染
- 静态化；(Nuxt.js)

### Vue的渲染流程

### 如何对比两个二叉树完全相等

```js
/**
 * Definition for a binary tree node.
 */
function TreeNode(val) {
    this.val = val;
    this.left = this.right = null;
 }

/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    // 边界情况处理
    if (!p || !q) return p === q
    if (p.val !== q.val) return false
    // 左、右子树递归
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};
```

### 实现promise.all()

```js
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('arguments must be an array'));
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedValues = new Array(promiseNum);
    for (let i = 0; i < promiseNum; i++) {
      // 微任务 排入队列
        Promise.resolve(promises[i]).then(function(value) {
          resolvedCounter++
          resolvedValues[i] = value
          if (resolvedCounter == promiseNum) {
            return resolve(resolvedValues)
          }
        }, function(reason) {
          return reject(reason)
        })
    }
  })
}
```
###  Map和Object的区别

1. 可迭代（Map实现了迭代器，可用for...of遍历，而Object不行）
2. Map可以直接拿到长度，而Object不行
3. 填入Map的元素，会保持原有的顺序，而Object无法做到。
4. Map可以使用省略号语法展开，而Object不行。
5. Map是一个纯哈希结构，而Object不是（它拥有自己的内部逻辑）。使用delete对Object的属性进行删除操作存在很多性能问题。所以，针对于存在大量增删操作的场景，使用Map更合适。
6. Map在存储大量数据的场景下表现更好，尤其是在key为未知状态，并且所有key和所有value分别为相同类型的情况下。
7. Map的遍历性能更好